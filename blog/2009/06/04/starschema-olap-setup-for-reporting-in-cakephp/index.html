
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>StarSchema (OLAP) setup for reporting in CakePHP - My New Home</title>
  <meta name="author" content="Martin Westin">

  
  <meta name="description" content="When you need to gather statistics and reporting data from a large number of transactions (easily >1&#8217;000&#8217;000 rows) you need to transfer &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://eimer.co/blog/2009/06/04/starschema-olap-setup-for-reporting-in-cakephp">
  <link href="/favicon.ico" rel="icon">

  <link href="/assets/bootstrap/css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="/assets/font-awesome/css/font-awesome.css" rel="stylesheet" type="text/css">

  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>

  <link href="/atom.xml" rel="alternate" title="My New Home" type="application/atom+xml">
  
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-11893308-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body    data-spy="scroll">

  <div class="container">
    <header class="jumbotron subhead" id="overview">
      
<div class="subscribe">
  <table>
    <tr>
      <td><span>Get Updates: &nbsp;</span></td>
      
      
      <td><a href="/atom.xml" class="btn"><i class="icon-cog"></i> By RSS</a></td>
      
      
      <td><a href="http://twitter.com/eimer" class="btn"><i class="icon-twitter-sign"></i> On Twitter</a></td>
      
    </tr>
  </table>
</div>

<h1 class="title">My New Home</h1>

  <p class="lead">migrated from the 10 year-old eimermusic.com</p>


      <div class="navbar">
  <div class="navbar-inner">
    <div class="container" style="width: auto;">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>
      <div class="nav-collapse">
                <ul class="nav">
          <li><a href="/">Home</a></li>
          <li><a href="/music">Music</a></li>
          <li><a href="/photos">Photos</a></li>
          <li><a href="/portfolio">Portfolio</a></li>
          <li><a href="/about">About</a></li>
        </ul>

        
          <form action="http://google.com/search" method="get" class="navbar-search pull-left">
            <fieldset role="search">
              <input type="hidden" name="q" value="site:eimer.co" />
              <input type="text" name="q" results="0" placeholder="Search" class="search-query span2" />
            </fieldset>
          </form>
        
        
      </div><!-- /.nav-collapse -->
    </div>
  </div><!-- /navbar-inner -->
</div>

    </header>
    <div id="main">
      <div id="content">
        <div class="row">
  
  <div class="span8">
    
  <header>
    
      <h1 class="entry-title">StarSchema (OLAP) Setup for Reporting in CakePHP</h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-06-04T00:00:00+02:00" pubdate data-updated="true">Jun 4<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  
  
  <div class="entry-content"><p>
When you need to gather statistics and reporting data from a large number of transactions (easily >1&#8217;000&#8217;000 rows) you need to transfer that data over to a reporting-friendly format to keep request times down. One popular database design for this is called a Star Schema. This is a simple re-usable StarSchema setup for CakePHP.
</p>




<p>
To make heads and tails of the following it help to have some basic understanding of star schemas and why anyone would use OLAP. If your gut-reaction is &#8220;Why not just do a find on the transaction data and format a reporting view from that?&#8221; then you should at least give the following page a look.
</p>


<p><a href="http://ciobriefings.com/Publications/WhitePapers/DesigningtheStarSchemaDatabase/tabid/101/Default.aspx">http://ciobriefings.com/&#8230;</a></p>

<h4>When do I need this?</h4>


<p></p>

<ul>
<li>The data you are reporting on is growing and your app is slowing down</li>
<li>The data is not stored the way you want to &#8220;view it&#8221; in your reports</li>
<li>You need to &#8220;view&#8221; your data in various different ways in your reports</li>
</ul>




<h4> Disclaimer</h4>


<p></p>

<p>
This article is to provide an implementation of a star schema setup for Cake. You still need to know how to DESIGN your schema. It is very important to plan ahead and create a schema that will accomodate ALL the ways (dimensions) you want to display your data. It is  a bit tricky to alter the schema afterwards.
</p>


<p>
This code uses some of ugly messy code that improves performance. The database goes against some Cake conventions (no pk!). It also contains some ugly messy code that is the fault of the author (me). Also this setup has only been run and tested on MySQL and uses a custom dbo that can put dynamic data into a Model&#8217;s resultset.
</p>


<p>
This article is about the star schema implementation. It could be extended to aggregated tables to improve display performance even further. How to do this is not explained here.
</p>




<h4>Pieces to the puzzle</h4>


<p></p>

<ul>
<li>Extended DBO</li>
<li>Fact Model</li>
<li>Dimension Models</li>
<li>A Controller example</li>
</ul>


<h3>Extended DBO</h3>

<p>
I found this extended DBO a long time ago. Credit should go where credit is due but I have lost the reference to the original author. The DBO did more but I picked out the resultSet() method which is what we need here. To get an extended mysqli driver replace the &#8220;mysql_&#8230;&#8221; methods with &#8220;mysqli_&#8230;&#8221;
</p>


<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>lang:php </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span></pre></td><td class="code"><pre><code class=><span class="line">
require_once (LIBS . 'model' . DS . 'datasources' . DS . 'dbo' . DS . 'dbo_mysql.php');
// app/models/datasources//dbo/dbo_mysql_ex.php
class DboMysqlEx extends DboMysql {
    var $description = "MySQL DBO Driver - Extended";
    
    // Extended 'resultSet' to allow alias processing
    // Fields should contain '((something)) AS Model__field'
    function resultSet(&$results) {
        $this->results =& $results;
        $this->map = array();
        $num_fields = mysql_num_fields($results);
        $index = 0;
        $j = 0;

        while ($j < $num_fields) {
            $column = mysql_fetch_field($results,$j);
            if (!empty($column->table)) {
                $this->map<$index++> = array($column->table, $column->name);
            } else {
                if (strpos($column->name, '__')) {
                    $parts = explode('__', $column->name);
                    $this->map<$index++> = array($parts<0>, $parts<1>);
                } else {
                    $this->map<$index++> = array(0, $column->name);
                }
            }
            $j++;
        }
    }
}
</span></code></pre></td></tr></table></div></figure></notextile></div>


<h3>Fact Model</h3>

<p>
The abstract fact model, the super, the parent, which all concrete fact models extend.
</p>


<p>
FactModel implements a few custom methods that are common among fact models. findFacts() is a custom find method that joins the fact model with all its dimensions and returns a nice data array with the requested fact. saveFact() is a custom save method that uses a custom query to automatically update each row if it exists already. This is done to improve performance (a lot).
</p>


<p></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>lang:php </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span></pre></td><td class="code"><pre><code class=><span class="line">
/*
 *  Abstract super-model for Facts
 */
class FactModel extends AppModel {

    var $name = 'FactModel';
        
    // I prefer using findFacts() directly but like this you could quickly make a find type of the whole thing
    function find($type, $options = array()) {
        switch ($type) {
            case 'facts':
                return $this->findFacts($options<'fact'>,$options);
            default:
                return parent::find($type, $options);
        }
    }

    // this method will always be specific to each fact model
    function gather( $start_time = null ) {
        debug($this->alias.' must implement gather()');
        return false;
    }

    //-- 'mapped' re-arranges the results in an array-hierarchy according to the group parameter.
    //-- E.G. grouping by weekday might return array keys mon,tue... instead of 0,1...
    function findFacts($fact, $options) {
        $defaults = array(
            'conditions' =>'',
            'fields' =>array(),
            'order' =>'',
            'group' =>'',
            'mapped'=>false
        );
        $options = array_merge($defaults,$options);
        
        $dimensions = $this->getAssociated('belongsTo');
        
        $joins = $this->useTable.' AS '.$this->alias;
        $this_name = $this->alias;
        foreach ( $dimensions as $k => $dim ) {
            $dimension = $this->$dim->useTable.' AS '.$dim;
            $fk = $this->belongsTo<$dim><'foreignKey'>;
            $joins = "($dimension INNER JOIN $joins ON $dim.id = $this_name.$fk)";
        }
        $fields = array_merge($options<'fields'>,array($fact.' AS '.$this->alias.'__fact',$options<'group'>,$options<'order'>));
        $fields = array_unique($fields);
        
        $db =& ConnectionManager::getDataSource($this->useDbConfig);
        $query = $db->renderStatement('select', array(
            'conditions' => $db->conditions($options<'conditions'>, true, true, $this),
            'fields' => join(', ', $fields),
            'table' => '',
            'alias' => '',
            'order' => $db->order($options<'order'>),
            'limit' => '',
            'joins' => $joins,
            'group' => $db->group($options<'group'>)
        ));             
        $raw_facts = $this->query($query);
        
        if ( $options<'mapped'> ) {
            $group_str = str_replace(' ','',$options<'group'>);
            $groups = explode(',',$group_str);
            $last_group = array_pop($groups);
            
            $mapped_facts = array();
            foreach ( $raw_facts as $key => $val ) {
                $domain =& $mapped_facts;
                foreach ( $groups as $group ) {
                    $gKey = Set::extract($raw_facts,$key.'.'.$group);
                    if ( !isset($domain< $gKey >) ) {
                        $domain< $gKey > = array();
                    }
                    $domain =& $domain< $gKey >;
                }
                $gKey = Set::extract($raw_facts,$key.'.'.$last_group);
                $domain<$gKey> = $val;
            }

            return $mapped_facts;
        } else {
            return $raw_facts;
        }
    }
    
    
    function saveFact($fact) {
        
        $keys = array_keys($fact<$this->alias>);
        $values = array_values($fact<$this->alias>);
        
        $fields = $this->_getFactFields();
        $update = '';
        foreach ( $fields as $field ) {
            $update .= ' `'.$field.'` = '.$fact<$this->alias><$field>.',';
        }
                
        $query = 'INSERT INTO `'.$this->useTable.'` (`'. implode('`,`', $keys) .'`) VALUES ('. implode(',', $values) .') ON DUPLICATE KEY UPDATE'.substr($update,0,-1);
        $this->query($query);
    }
    
    function _getFactFields() {
        $fields = array();
        foreach ( $this->_schema as $field => $params ) {
            if ( !isset($params<'key'>) ) {
                $fields<> = $field;
            }
        }
        return $fields;
    }
}
</span></code></pre></td></tr></table></div></figure></notextile></div>


<h3>Example FactSentSms</h3>

<p>
A simple example of a concrete model extending FactModel. This one tracks outgoing SMS messages for a few dimensions. More on dimensions shortly.
</p>


<p>
In this example the gather() method is quite simple. It could contain any number of complex calculations or pulling of associated data. This method does all the heavy lifting of the data and an initial gathering of an existing transaction table can take a long time.

Notice that the fact table contains a field referencing the original primary key from the transaction table. This is to ensure that we can update the data without accidentally overwriting rows or creating duplicates. The table definition makes a unique key of the composite of all dimensions and this id. There is no primary key, by design.
</p>


<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>lang:sql </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span></pre></td><td class="code"><pre><code class=><span class="line">
CREATE TABLE `fact_sent_smses` (
  `dimension_time_id` int(11) unsigned NOT NULL,
  `dimension_client_id` int(11) unsigned NOT NULL,
  `dimension_type_id` int(11) unsigned NOT NULL,
  `dimension_module_id` int(11) unsigned NOT NULL,
  `outgoing_id` int(11) unsigned NOT NULL,
  `num_smses` int(11) default '0',
  `response_code` int(11) default '0',
  `tarif_total` int(11) default '0',
  UNIQUE KEY `dimension_time_id` (`dimension_time_id`,`dimension_client_id`,`dimension_type_id`,`outgoing_id`,`dimension_module_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_binary
</span></code></pre></td></tr></table></div></figure></notextile></div>


<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>lang:php </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span></pre></td><td class="code"><pre><code class=><span class="line">
/*
 *  Tracks outgoing messages with daily grain.
 */
App::import('Model','FactModel');
class FactSentSms extends FactModel {
    var $name = 'FactSentSms';
    var $useTable = 'fact_sent_smses';
    
    // dimensions are specified as belongsTo accosiations.
    var $belongsTo = array('DimensionTime','DimensionClient','DimensionType','DimensionModule');


    // gather new facts from transation model, run periodically from cron shell
    // this method will always be specific to each fact model
    function gather( $start_time = null ) {
        if ( empty($start_time) ) {
            $start_time = strtotime( '-1 hour', time() );
        }
        $start_date = date('Y-m-d H:i:s', $start_time);

        $OutgoingSms =& ClassRegistry::init('OutgoingSms');
        $page = 1;
        while ( $all = $OutgoingSms->find('all', array(
            'fields'=>array(
                '*',
                'DATE(OutgoingSms.created) AS OutgoingSms__date',
                'TIME(OutgoingSms.created) AS OutgoingSms__time',
                'DAYOFWEEK(OutgoingSms.created) AS OutgoingSms__day_of_week',
                'DAYOFMONTH(OutgoingSms.created) AS OutgoingSms__day_of_month',
                'DAYOFYEAR(OutgoingSms.created) AS OutgoingSms__day_of_year',
                'MONTH(OutgoingSms.created) AS OutgoingSms__month',
                'QUARTER(OutgoingSms.created) AS OutgoingSms__quarter',
                'YEAR(OutgoingSms.created) AS OutgoingSms__year'
            ),
            'conditions'=>array(
                'OutgoingSms.created >' => $start_date
            ),
            'recursive'=>'0',
            'order'=>'OutgoingSms.created ASC',
            'limit'=>'5000',
            'page' => $page++
        )) ) {
            foreach ( $all as $one ) {
                // Associate this fact with a record from each dimension
                $fact<'FactSentSms'><'dimension_time_id'> = $this->DimensionTime->getDimensionFor($one<'OutgoingSms'>);
                $fact<'FactSentSms'><'dimension_type_id'> = $this->DimensionType->getDimensionFor($one<'OutgoingSms'>);
                $fact<'FactSentSms'><'dimension_client_id'> = $this->DimensionClient->getDimensionFor($one<'OutgoingSms'>);
                $fact<'FactSentSms'><'dimension_module_id'> = $this->DimensionModule->getDimensionFor($one<'OutgoingSms'>);
                
                // Simple facts tracked
                $fact<'FactSentSms'><'response_code'> = $one<'OutgoingSms'><'response_code'>;
                $fact<'FactSentSms'><'tarif_total'> = $one<'OutgoingSms'><'data'><'tariffClass'>;
                $fact<'FactSentSms'><'outgoing_id'> = $one<'OutgoingSms'><'id'>; // copy original id so that we can do updates reliably
                $fact<'FactSentSms'><'num_smses'> = count(split_sms($one<'OutgoingSms'><'data'><'userData'>)); //WARNING. this line will fail unless you also have a function to split SMS messages

                $this->saveFact($fact);
            }
        }// end big while
    }
}
</span></code></pre></td></tr></table></div></figure></notextile></div>


<h3>Dimension Models</h3>

<p>
The dimension models are often simple. They only implement one custom method (also often simple): getDimensionFor(). This method takes a single record from the transaction model and figures out which dimension it belongs to. E.G. It can look at the created field and find the right time dimension to match that timestamp. It can check the a status code and simply map to a record representing that code.
</p>


<p>
The following example is a time dimension with a daily grain. I.E. the smallest increment in time is a day. I chose this dimension as the example since it is one that can be re-used, often without modification. If you look at gather() (above) you can see that I let MySQL do all the heavy calculations to pick out the date components. The method tries to find an existing dimension record and failing that it creates a new record. Simple pimple!
</p>


<p>
This example also implements the most basic form of caching. Since the dimensions usually contain a very limited number of records caching each one in memory will dramatically increase the performance of the gathering process. Say you have the price dimension with 10 prices (that is 10 records) and 800&#8217;000 transactions to map. Evenly distributed, each price record will be queried 80&#8217;000 times. 79&#8217;999 times to many. So by caching the queries you save your database 799&#8217;990 redundant queries just for a single dimension. My simple cache is a lot faster than using cacheQueries, probably because it is so very basic. When it is all that is needed I will gladly take the performance boost.
<p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>lang:sql </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span></pre></td><td class="code"><pre><code class=><span class="line">

CREATE TABLE `dimension_time` (
    `id` int(11) unsigned NOT NULL auto_increment,
    `day_of_week` int(11) default NULL,
    `day_of_month` int(11) default NULL,
    `day_of_year` int(11) default NULL,
    `month` int(11) default NULL,
    `quarter` int(11) default NULL,
    `year` int(11) default NULL,
    `holiday` int(1) default '0',
    `weekend` int(1) default '0',
    PRIMARY KEY  (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=52 DEFAULT CHARSET=utf8 COLLATE=utf8_binary;

</span></code></pre></td></tr></table></div></figure></notextile></div>
<br />
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>lang:php </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span></pre></td><td class="code"><pre><code class=><span class="line">
/*
 *  Time dimension with daily grain
 */
class DimensionTime extends AppModel {
    var $name = 'DimensionTime';
    var $useTable = 'dimension_time';
    //var $cacheQueries = true;
    var $dim_cache; // lesson learned: Do your own caching.

    function getDimensionFor($one) {
        if ( empty($one<'created'>) ) {
            $one<'created'> = '2000-01-01 00:00:00';            
            $one<'day_of_week'> = '1';
            $one<'day_of_month'> = '1';
            $one<'day_of_year'> = '1';
            $one<'month'> = '1';
            $one<'quarter'> = '1';
            $one<'year'> = '2000';
        }

        $dim_time = null;
        //-> add cache search here
        if ( !empty( $this->dim_cache< $one<'year'>.$one<'day_of_year'> > ) ) {
            $dim_time = $this->dim_cache< $one<'year'>.$one<'day_of_year'> >;
        }

        if ( empty($dim_time) ) {
            $dim_time = $this->find('first',array(
                'conditions' => array(
                    'DimensionTime.day_of_year' => $one<'day_of_year'>,
                    'DimensionTime.year' => $one<'year'>
                )
            ));
        }
        if ( empty($dim_time) ) {
            $dim_time<'DimensionTime'> = array(
                'day_of_week'=> $one<'day_of_week'>,
                'day_of_month'=> $one<'day_of_month'>,
                'day_of_year'=> $one<'day_of_year'>,
                'month'=> $one<'month'>,
                'quarter'=> $one<'quarter'>,
                'year'=> $one<'year'>,
                'holiday'=> -1,
                'weekend'=> ($one<'day_of_week'>>5) ? 1: 0,
            );
            $this->create($dim_time);
            $this->save($dim_time);
            $dim_time = $this->read();
        }
        //-> save to cache here     
        $this->dim_cache< $one<'year'>.$one<'day_of_year'> > = $dim_time;

        return $dim_time<'DimensionTime'><'id'>;
    }
    
}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>
Then just rinse and repeat. Each dimension is very similar in its design. You just have to figure out what key values you need to store to define the desired &#8220;grain&#8221;. Often this is a simple as using the categories a product can be in or the different status codes returned for a message.
</p>


### A ReportsController example
<p>
This is a simple ReportsController that uses the model FactSentSms to get statistics for pretty charts in the view. (Charts will not be covered here.) The first example method below is used to load up data for stats showing how many messages have been sent per weekday. The fact you find is usually a SUM(), COUNT() or AVG() or some other SQL function.
</p>
<p>
It looks a lot like a normal find. You can use order and conditions like normal. In the first example we only way to count records where the response code is a successful transaction (you need to know our system to know exactly why they are this way). but for and error report we want the opposite.
</p>
<p>
Group takes on a slightly special meaning here. It is used to define the dimension(s) from which to view the data. In the first example simply the day of week from the time dimension. You can add more groupings to get your data returned as a multi-dimensional array, as in the modules_and_types() method.
</p>
<p>
Mapped is a nifty little thing that replaces numerical array keys (0-n) with meaningful keys like: monday-sunday or 1-7 for day of week and  1-31 for day of month. It is a bit like findList() in that it prepares your data for the table or graph in the view.
</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>lang:php </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span></pre></td><td class="code"><pre><code class=><span class="line">
class ReportsController extends AppController {
    var $name = 'Reports';
    var $uses = array('FactSentSms');
    var $billableResponseCodes = array('0','15'); // only these response codes result in a transaction.

    // show successful transactions per weekday
    function weekdays() {
        $weekly_smses = $this->FactSentSms->findFacts('Sum(FactSentSms.num_smses)',array(
            'group'=>'DimensionTime.day_of_week',
            'order'=>'DimensionTime.day_of_week',
            'conditions'=>array(
                '(FactSentSms.response_code IN ('.implode(',',$this->billableResponseCodes).') )'
            ),
            'mapped'=>true
        ));
        $this->set('weekly_smses',$weekly_smses);       
    }
    
    // show which modules (=parts of the system) have sent which types of messages
    function modules_and_types() {
        $all_modules = $this->FactSentSms->findFacts($sum,array(
            'fields' => array('Sum(FactSentSms.tarif_total) AS FactSentSms__tarif_total'), // additional fields can be defined
            'group'=>'DimensionModule.name, DimensionType.type', // multiple dimensions are possible
            'order'=>'DimensionModule.name',
            'conditions'=>array(
                '(FactSentSms.response_code IN ('.implode(',',$this->billableResponseCodes).') )'
            ),
            'mapped'=>true
        ));
        $this->set('all_modules',$all_modules);
    }
    
    // show error types for this month
    function errors_this_month() {
        $responses = $this->FactSentSms->findFacts($sum,array(
            'group'=>'FactSentSms.response_code',
            'order'=>'FactSentSms.response_code',
            'conditions'=>array(
                '(FactSentSms.response_code NOT IN ('.implode(',',$this->billableResponseCodes).') )',
                'DimensionTime.month'=>date('m'),
                'DimensionTime.year'=>date('Y')
            ),
            'mapped'=>true
        ));             
        $this->set('responses',$responses);
    }
}
</span></code></pre></td></tr></table></div></figure></notextile></div>

### Conclusion  
<p>
I hope you can start to see the benefits. Once the schema is setup we can write any number of reporting queries and &#8220;look at&#8221; the data from many different directions very quickly. For example, doing the weekly example on ≈220&#8217;000 records on our system is just over a second for the full Cake request cycle including rendering of the html. That is pretty dang good for a single (2 year old) rack server if you ask me.
</p>
<p>
If you design your dimensions cleverly they can be re-used for many fact tables. The time dimension is a prime candidate here. I can use that for all reports of all types of facts since it check for the generic created field.
</p>    

<p style="font-size:11px;">published @ <a href="http://bakery.cakephp.org/articles/view/starschema-olap-setup-for-reporting">http://bakery.cakephp.org/articles/view/starschema-olap-setup-for-reporting</a>
</p>

</div>

  


    <footer>
      <p class="meta">
        
  

<span class="byline author vcard">Posted by <span class="fn">Martin Westin</span></span>

        








  


<time datetime="2009-06-04T00:00:00+02:00" pubdate data-updated="true">Jun 4<span>th</span>, 2009</time>
        


      </p>
      
        <div class="sharing">
  <br/>
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://eimer.co/blog/2009/06/04/starschema-olap-setup-for-reporting-in-cakephp/" data-via="eimer" data-counturl="http://eimer.co/blog/2009/06/04/starschema-olap-setup-for-reporting-in-cakephp/" >Tweet</a>
  
  
  
</div>

      
      <p class="meta">
        
          <a class="basic-alignment pull-left" href="/blog/2009/02/18/one-core-one-app-multiple-domains-for-cakephp/" title="Previous Post: One core, one app, multiple domains for CakePHP">&laquo; One core, one app, multiple domains for CakePHP</a>
        
        
          <a class="basic-alignment pull-right" href="/blog/2009/06/29/javascript-variable-definitions/" title="Next Post: Javascript variable definitions">Javascript variable definitions &raquo;</a>
        
      </p>
    </footer>

    
  </div>

  
    
  <div class="span4 sidebar">
    <div class="well">
      
        <section>
  <h2>Recent Posts</h2>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/07/17/shelling-out-from-a-ruby-app-to-a-ruby-app-without-bundler-conflicts/">Shelling out from a ruby app to a ruby app without bundler conflicts</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/02/29/winning-two-gsma-global-mobile-awards/">Winning Two GSMA Global Mobile Awards</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/11/09/looping-through-large-and-slow-datasets-in-ruby/">Looping through large and slow datasets in Ruby</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/11/03/quick-tip-ios-and-web-graphics-in-illustrator/">Quick Tip: iOS and web graphics in Illustrator</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/07/26/patents-gone-crazy/">Patents Gone Crazy</a>
      </li>
    
  </ul>
</section>

<section>
  <h2>GitHub Repos</h2>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/eimermusic">@eimermusic</a> on GitHub
  
  <script type="text/javascript">
    $(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'eimermusic',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h2>Latest Tweets</h2>
  <ul id="tweets">
    <li class="loading">Status updating...</li>
  </ul>
  
    <a href="http://twitter.com/eimer" class="twitter-follow-button" data-show-count="false">Follow @eimer</a>
  
</section>





      
    </div>
  </div>


  
</div>


      </div>
    </div>
    <footer class="footer"><p>
  Copyright &copy; 2013 - Martin Westin -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span> -
  
    <span class="credit">Theme by <a href="http://brianarmstrong.org">Brian Armstrong</a></span>
  
</p>
</footer>
    <script src="/assets/bootstrap/js/bootstrap.min.js"></script>








  </div>
</body>
</html>
